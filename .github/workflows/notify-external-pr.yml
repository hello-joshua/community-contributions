name: Notify External PR

on:
  pull_request:
    types: [opened]

permissions:
  contents: read
  pull-requests: read

jobs:
  notify:
    runs-on: ubuntu-latest
    # Only run for external PRs (not from grafana org members)
    if: github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR' || 
        github.event.pull_request.author_association == 'FIRST_TIMER' ||
        github.event.pull_request.author_association == 'NONE'
    
    steps:
      - name: Check if alerting-related (pilot scope)
        id: check-scope
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get changed files
          files=$(gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json files --jq '.files[].path' || echo "")
          
          # Check if any files are in alerting paths
          is_alerting="false"
          if echo "$files" | grep -qE "(pkg/services/ngalert|public/app/features/alerting|apps/alerting)"; then
            is_alerting="true"
          fi
          
          # Check labels for area/alerting
          labels=$(gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json labels --jq '.labels[].name' || echo "")
          if echo "$labels" | grep -q "area/alerting"; then
            is_alerting="true"
          fi
          
          echo "is-alerting=$is_alerting" >> "$GITHUB_OUTPUT"
          echo "Alerting-related: $is_alerting"

      - name: Categorize PR
        id: categorize
        if: steps.check-scope.outputs.is-alerting == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get PR stats
          pr_data=$(gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json additions,deletions,files,title,body)
          
          additions=$(echo "$pr_data" | jq '.additions')
          deletions=$(echo "$pr_data" | jq '.deletions')
          total_changes=$((additions + deletions))
          
          # Determine size
          if [ "$total_changes" -lt 50 ]; then
            size="small"
          elif [ "$total_changes" -lt 300 ]; then
            size="medium"
          else
            size="large"
          fi
          
          # Determine type based on file paths
          files=$(echo "$pr_data" | jq -r '.files[].path')
          
          type="feature"
          if echo "$files" | grep -qE "^docs/|\.md$"; then
            if ! echo "$files" | grep -qvE "^docs/|\.md$"; then
              type="docs"
            fi
          fi
          
          # Check title for bug indicators
          title=$(echo "$pr_data" | jq -r '.title')
          if echo "$title" | grep -qiE "(fix|bug|issue|error|crash|broken)"; then
            type="bugfix"
          fi
          
          echo "size=$size" >> "$GITHUB_OUTPUT"
          echo "type=$type" >> "$GITHUB_OUTPUT"
          echo "additions=$additions" >> "$GITHUB_OUTPUT"
          echo "deletions=$deletions" >> "$GITHUB_OUTPUT"
          echo "title=$title" >> "$GITHUB_OUTPUT"
          
          echo "Categorized: $type ($size) - +$additions/-$deletions"

      - name: Get Vault secrets
        if: steps.check-scope.outputs.is-alerting == 'true'
        uses: grafana/shared-workflows/actions/get-vault-secrets@main
        with:
          repo_secrets: |
            OPENAI_API_KEY=openapi:key
            SLACK_WEBHOOK=slack:webhook

      - name: Generate AI summary
        id: summary
        if: steps.check-scope.outputs.is-alerting == 'true' && env.OPENAI_API_KEY != ''
        env:
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          # Note: Vault secret is loaded as OPENAI_API_KEY from openapi:key
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get PR details
          pr_data=$(gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json title,body,files)
          
          title=$(echo "$pr_data" | jq -r '.title')
          body=$(echo "$pr_data" | jq -r '.body // "No description"' | head -c 500)
          files=$(echo "$pr_data" | jq -r '.files[].path' | head -20 | tr '\n' ', ')
          
          # Generate summary via OpenAI
          prompt="Summarize this PR in 2-3 sentences. Title: $title. Description: $body. Files changed: $files"
          
          response=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4o-mini\",
              \"messages\": [{\"role\": \"user\", \"content\": \"$prompt\"}],
              \"max_tokens\": 150
            }" || echo "{}")
          
          summary=$(echo "$response" | jq -r '.choices[0].message.content // "Unable to generate summary"')
          
          # Escape for GitHub output
          summary="${summary//'%'/'%25'}"
          summary="${summary//$'\n'/'%0A'}"
          summary="${summary//$'\r'/'%0D'}"
          
          echo "summary=$summary" >> "$GITHUB_OUTPUT"

      - name: Send Slack notification
        if: steps.check-scope.outputs.is-alerting == 'true' && env.SLACK_WEBHOOK != ''
        env:
          SLACK_WEBHOOK: ${{ env.SLACK_WEBHOOK }}
          # Pass step outputs via env vars (safer than template interpolation in shell)
          PR_TITLE: ${{ steps.categorize.outputs.title }}
          PR_SIZE: ${{ steps.categorize.outputs.size }}
          PR_TYPE: ${{ steps.categorize.outputs.type }}
          PR_SUMMARY: ${{ steps.summary.outputs.summary }}
          PR_ADDITIONS: ${{ steps.categorize.outputs.additions }}
          PR_DELETIONS: ${{ steps.categorize.outputs.deletions }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
        run: |
          # Use env vars (sanitized by GitHub Actions runtime)
          pr_url="https://github.com/${REPO}/pull/${PR_NUMBER}"
          pr_author="external contributor"
          
          # Sanitize title and summary for JSON (escape quotes and newlines)
          pr_title=$(echo "$PR_TITLE" | tr -d '\n\r' | sed 's/"/\\"/g' | head -c 100)
          pr_summary=$(echo "$PR_SUMMARY" | tr -d '\n\r' | sed 's/"/\\"/g' | head -c 500)
          
          # Set emoji based on type
          case "$PR_TYPE" in
            "docs") emoji="üìù" ;;
            "bugfix") emoji="üêõ" ;;
            *) emoji="‚ú®" ;;
          esac
          
          # Set color based on size
          case "$PR_SIZE" in
            "small") color="#36a64f" ;;  # green
            "medium") color="#ff9800" ;; # orange
            "large") color="#f44336" ;;  # red
          esac
          
          # Build Slack message
          payload=$(cat <<EOF
          {
            "attachments": [{
              "color": "$color",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "$emoji External PR: $PR_TYPE ($PR_SIZE)",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*<$pr_url|$pr_title>*\nby $pr_author"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Summary:* $pr_summary"
                  }
                },
                {
                  "type": "context",
                  "elements": [{
                    "type": "mrkdwn",
                    "text": "Size: $PR_SIZE | Type: $PR_TYPE | +${PR_ADDITIONS}/-${PR_DELETIONS} lines"
                  }]
                }
              ]
            }]
          }
          EOF
          )
          
          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_WEBHOOK"
          
          echo "Slack notification sent!"

