name: 'Categorize PR'
description: 'Automatically categorize PRs by size and type based on changes and existing labels'
inputs:
  github-token:
    description: 'GitHub token for API access'
    required: true
  pr-number:
    description: 'Pull request number'
    required: true
  pr-body:
    description: 'Pull request body/description'
    required: false
    default: ''
outputs:
  size:
    description: 'Detected size category (small/medium/large)'
    value: ${{ steps.categorize.outputs.size }}
  type:
    description: 'Detected type category (docs/bugfix/refactor/feature)'
    value: ${{ steps.categorize.outputs.type }}
  size-label:
    description: 'Size label to apply'
    value: ${{ steps.categorize.outputs.size-label }}
  type-label:
    description: 'Type label to apply'
    value: ${{ steps.categorize.outputs.type-label }}
  conflict:
    description: 'Whether there is a conflict between contributor selection and auto-detection'
    value: ${{ steps.categorize.outputs.conflict }}

runs:
  using: 'composite'
  steps:
    - name: Get PR details and changes
      id: pr-details
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ inputs.pr-number }}
      run: |
        # Get PR file changes and metadata
        pr_data=$(gh pr view "$PR_NUMBER" --json files,title,body,labels)
        pr_files=$(echo "$pr_data" | jq '.files')
        
        # Count lines changed and files touched
        lines_added=$(echo "$pr_files" | jq '[.[].additions] | add // 0')
        lines_deleted=$(echo "$pr_files" | jq '[.[].deletions] | add // 0')
        total_lines=$((lines_added + lines_deleted))
        files_count=$(echo "$pr_files" | jq 'length')
        
        echo "lines-changed=$total_lines" >> "$GITHUB_OUTPUT"
        echo "files-count=$files_count" >> "$GITHUB_OUTPUT"
        
        # Get file paths for type detection
        file_paths=$(echo "$pr_files" | jq -r '.[].path' | tr '\n' ',' | sed 's/,$//')
        echo "file-paths=$file_paths" >> "$GITHUB_OUTPUT"
        
        # Get existing labels
        labels=$(echo "$pr_data" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
        echo "existing-labels=$labels" >> "$GITHUB_OUTPUT"
        
        # Get PR title (for type detection in addition to body)
        pr_title=$(echo "$pr_data" | jq -r '.title // ""')
        echo "pr-title=$pr_title" >> "$GITHUB_OUTPUT"

    - name: Categorize PR
      id: categorize
      shell: bash
      env:
        LINES_CHANGED: ${{ steps.pr-details.outputs.lines-changed }}
        FILES_COUNT: ${{ steps.pr-details.outputs.files-count }}
        FILE_PATHS: ${{ steps.pr-details.outputs.file-paths }}
        EXISTING_LABELS: ${{ steps.pr-details.outputs.existing-labels }}
        PR_BODY: ${{ inputs.pr-body }}
        PR_TITLE: ${{ steps.pr-details.outputs.pr-title }}
      run: |
        # Determine size
        if [ "$LINES_CHANGED" -lt 100 ] && [ "$FILES_COUNT" -le 3 ]; then
          SIZE="small"
        elif [ "$LINES_CHANGED" -lt 500 ] && [ "$FILES_COUNT" -le 10 ]; then
          SIZE="medium"
        else
          SIZE="large"
        fi
        
        echo "size=$SIZE" >> "$GITHUB_OUTPUT"
        echo "size-label=size:$SIZE" >> "$GITHUB_OUTPUT"
        
        # Determine type from existing labels first
        TYPE=""
        if echo "$EXISTING_LABELS" | grep -q "type/docs\|area/docs"; then
          TYPE="docs"
        elif echo "$EXISTING_LABELS" | grep -q "type/bug"; then
          TYPE="bugfix"
        elif echo "$EXISTING_LABELS" | grep -q "type/feature"; then
          TYPE="feature"
        elif echo "$EXISTING_LABELS" | grep -q "type/refactor"; then
          TYPE="refactor"
        fi
        
        # Fallback to file path analysis if no type labels exist
        if [ -z "$TYPE" ]; then
          # Strip HTML comments (including multi-line) from PR body using perl
          # perl's /s flag makes . match newlines, /g is global
          cleaned_body=$(echo "$PR_BODY" | perl -pe 's/<!--.*?-->//gs')
          
          # Strip common template questions and checklists to avoid false positives
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/What is this feature\?.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/Which issue.*does this PR fix\?.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/Why do we need this feature\?.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/Who is this feature for\?.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/Notes to the Reviewer.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/prove my fix is effective or my feature works.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/added necessary documentation.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/The docs are updated.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/\*\*Special notes for your reviewer:\*\*.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/Please check that:.*//gi')
          
          # Strip unfilled "Closes/Fixes #" placeholders (must be after template questions)
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/^[[:space:]]*(Closes|closes|Fixes|fixes|Resolves|resolves)[[:space:]]+#[[:space:]]*$//g')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/\b(Closes|closes|Fixes|fixes|Resolves|resolves) #[[:space:]]*$//g')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/\b(Closes|closes|Fixes|fixes|Resolves|resolves) #[[:space:]]*\n/\n/g')
          
          # Scoring-based classification: count keyword occurrences for each type
          # Title keywords weighted 2x, body keywords 1x
          
          # DOCS scoring
          docs_score=0
          docs_title_count=$(echo "$PR_TITLE" | grep -ioE "\b(documentation|docs|swagger|openapi|jsdoc|readme)\b" | wc -l | tr -d '\n' || echo 0)
          docs_body_count=$(echo "$cleaned_body" | grep -ioE "\b(documentation|docs|swagger|openapi|jsdoc|readme)\b" | wc -l | tr -d '\n' || echo 0)
          docs_score=$((${docs_title_count:-0} * 2 + ${docs_body_count:-0}))
          if echo "$FILE_PATHS" | grep -q "docs/\|contribute/\|\.md$"; then
            docs_score=$((docs_score + 3))
          fi
          
          # BUGFIX scoring
          bugfix_score=0
          bugfix_title_strong=$(echo "$PR_TITLE" | grep -ioE "\b(bug|bugfix|critical|regression)\b" | wc -l | tr -d '\n' || echo 0)
          bugfix_body_strong=$(echo "$cleaned_body" | grep -ioE "\b(bug|bugfix|critical|regression)\b" | wc -l | tr -d '\n' || echo 0)
          bugfix_title_weak=$(echo "$PR_TITLE" | grep -ioE "\b(fix(es|ed|ing)?)\b" | wc -l | tr -d '\n' || echo 0)
          bugfix_body_weak=$(echo "$cleaned_body" | grep -ioE "\b(fix(es|ed|ing)?)\b" | wc -l | tr -d '\n' || echo 0)
          bugfix_score=$((${bugfix_title_strong:-0} * 3 + ${bugfix_body_strong:-0} * 2 + ${bugfix_title_weak:-0} + ${bugfix_body_weak:-0}))
          if echo "$FILE_PATHS" | grep -qE "(^|/)tests?/.*\.(test|spec)\.|__tests__/"; then
            bugfix_score=$((bugfix_score + 2))
          fi
          
          # REFACTOR scoring
          refactor_score=0
          refactor_title_count=$(echo "$PR_TITLE" | grep -ioE "\b(refactor(ing)?|reorganiz|restructur|simplify|consolidate|extract|cleanup)\b" | wc -l | tr -d '\n' || echo 0)
          refactor_body_count=$(echo "$cleaned_body" | grep -ioE "\b(refactor(ing)?|reorganiz|restructur|simplify|consolidate|extract|cleanup)\b" | wc -l | tr -d '\n' || echo 0)
          refactor_score=$((${refactor_title_count:-0} * 2 + ${refactor_body_count:-0}))
          
          # FEATURE scoring
          feature_score=0
          feature_title_count=$(echo "$PR_TITLE" | grep -ioE "\b(feat(ure)?|add(s|ed|ing)?|new|implement(s|ed|ing)?|allow(s|ed|ing)?)\b" | wc -l | tr -d '\n' || echo 0)
          feature_body_count=$(echo "$cleaned_body" | grep -ioE "\b(feat(ure)?|add(s|ed|ing)?|new|implement(s|ed|ing)?|enhance(ment)?|update(s|d|ing)?|upgrade(s|d)?|improve(s|d|ment)?|allow(s|ed|ing)?)\b" | wc -l | tr -d '\n' || echo 0)
          feature_score=$((${feature_title_count:-0} * 2 + ${feature_body_count:-0}))
          
          # Pick type with highest score
          if [ "$docs_score" -gt 0 ] && [ "$docs_score" -ge "$bugfix_score" ] && [ "$docs_score" -ge "$feature_score" ] && [ "$docs_score" -ge "$refactor_score" ]; then
            TYPE="docs"
          elif [ "$bugfix_score" -gt "$feature_score" ] && [ "$bugfix_score" -gt "$refactor_score" ]; then
            TYPE="bugfix"
          elif [ "$feature_score" -gt "$refactor_score" ]; then
            TYPE="feature"
          elif [ "$refactor_score" -gt 0 ]; then
            TYPE="refactor"
          else
            # Default to feature if all scores are 0
            TYPE="feature"
          fi
          
          # Debug: output scores for troubleshooting
          echo "Classification scores: docs=$docs_score bugfix=$bugfix_score refactor=$refactor_score feature=$feature_score -> $TYPE"
          echo "debug-scores=docs:$docs_score bugfix:$bugfix_score refactor:$refactor_score feature:$feature_score" >> "$GITHUB_OUTPUT"
        fi
        
        # Ensure TYPE is set (should never be empty, but safety check)
        if [ -z "$TYPE" ]; then
          echo "ERROR: TYPE is empty after scoring! Defaulting to feature"
          TYPE="feature"
        fi
        
        echo "type=$TYPE" >> "$GITHUB_OUTPUT"
        echo "type-label=pr-category:$TYPE" >> "$GITHUB_OUTPUT"
        
        # Check for conflicts with contributor selection
        CONFLICT="false"
        if echo "$PR_BODY" | grep -q "Small" && [ "$SIZE" != "small" ]; then
          CONFLICT="true"
        elif echo "$PR_BODY" | grep -q "Medium" && [ "$SIZE" != "medium" ]; then
          CONFLICT="true"
        elif echo "$PR_BODY" | grep -q "Large" && [ "$SIZE" != "large" ]; then
          CONFLICT="true"
        fi
        
        echo "conflict=$CONFLICT" >> "$GITHUB_OUTPUT"
        
        echo "Categorized as: size=$SIZE, type=$TYPE"
        if [ "$CONFLICT" = "true" ]; then
          echo "WARNING: Conflict detected with contributor's self-selection"
        fi

