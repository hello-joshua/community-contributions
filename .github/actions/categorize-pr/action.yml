name: 'Categorize PR'
description: 'Automatically categorize PRs by size and type based on changes and existing labels'
inputs:
  github-token:
    description: 'GitHub token for API access'
    required: true
  pr-number:
    description: 'Pull request number'
    required: true
  pr-body:
    description: 'Pull request body/description'
    required: false
    default: ''
  openai-api-key:
    description: 'OpenAI API key for LLM-based type classification'
    required: false
    default: ''
outputs:
  size:
    description: 'Detected size category (small/medium/large)'
    value: ${{ steps.categorize.outputs.size }}
  type:
    description: 'Detected type category (docs/bugfix/feature)'
    value: ${{ steps.categorize.outputs.type }}
  size-label:
    description: 'Size label to apply'
    value: ${{ steps.categorize.outputs.size-label }}
  type-label:
    description: 'Type label to apply'
    value: ${{ steps.categorize.outputs.type-label }}
  disagreement:
    description: 'Whether label and AI classifications disagree'
    value: ${{ steps.categorize.outputs.disagreement }}
  disagreement-label:
    description: 'Label-based classification when disagreement occurs'
    value: ${{ steps.categorize.outputs.disagreement-label }}
  disagreement-ai:
    description: 'AI-based classification when disagreement occurs'
    value: ${{ steps.categorize.outputs.disagreement-ai }}

runs:
  using: 'composite'
  steps:
    - name: Get PR details and changes
      id: pr-details
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ inputs.pr-number }}
      run: |
        # Get PR file changes and metadata
        pr_data=$(gh pr view "$PR_NUMBER" --json files,title,body,labels)
        pr_files=$(echo "$pr_data" | jq '.files')
        
        # Count lines changed and files touched
        lines_added=$(echo "$pr_files" | jq '[.[].additions] | add // 0')
        lines_deleted=$(echo "$pr_files" | jq '[.[].deletions] | add // 0')
        total_lines=$((lines_added + lines_deleted))
        files_count=$(echo "$pr_files" | jq 'length')
        
        echo "lines-changed=$total_lines" >> "$GITHUB_OUTPUT"
        echo "files-count=$files_count" >> "$GITHUB_OUTPUT"
        
        # Get file paths for type detection
        file_paths=$(echo "$pr_files" | jq -r '.[].path' | tr '\n' ',' | sed 's/,$//')
        echo "file-paths=$file_paths" >> "$GITHUB_OUTPUT"
        
        # Get existing labels
        labels=$(echo "$pr_data" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
        echo "existing-labels=$labels" >> "$GITHUB_OUTPUT"
        
        # Get PR title (for type detection in addition to body)
        pr_title=$(echo "$pr_data" | jq -r '.title // ""')
        echo "pr-title=$pr_title" >> "$GITHUB_OUTPUT"

    - name: Categorize PR
      id: categorize
      shell: bash
      env:
        LINES_CHANGED: ${{ steps.pr-details.outputs.lines-changed }}
        FILES_COUNT: ${{ steps.pr-details.outputs.files-count }}
        FILE_PATHS: ${{ steps.pr-details.outputs.file-paths }}
        EXISTING_LABELS: ${{ steps.pr-details.outputs.existing-labels }}
        PR_BODY: ${{ inputs.pr-body }}
        PR_TITLE: ${{ steps.pr-details.outputs.pr-title }}
        OPENAI_API_KEY: ${{ inputs.openai-api-key }}
      run: |
        # Determine size with validation
        if [ -z "$LINES_CHANGED" ] || [ -z "$FILES_COUNT" ]; then
          echo "ERROR: Missing size metrics, defaulting to medium"
          SIZE="medium"
        else
          if [ "$LINES_CHANGED" -lt 100 ] && [ "$FILES_COUNT" -le 3 ]; then
            SIZE="small"
          elif [ "$LINES_CHANGED" -lt 500 ] && [ "$FILES_COUNT" -le 10 ]; then
            SIZE="medium"
          else
            SIZE="large"
          fi
        fi
        
        echo "size=$SIZE" >> "$GITHUB_OUTPUT"
        echo "size-label=size:$SIZE" >> "$GITHUB_OUTPUT"
        
        # Determine type from existing labels first
        # Priority: bug > feature > docs (refactor removed - too rare for external PRs)
        LABEL_TYPE=""
        
        # Add commas for exact matching
        labels_with_bounds=",$EXISTING_LABELS,"
        
        if echo "$labels_with_bounds" | grep -q ",type/bug,"; then
          LABEL_TYPE="bugfix"
        elif echo "$labels_with_bounds" | grep -q ",type/feature,"; then
          LABEL_TYPE="feature"
        elif echo "$labels_with_bounds" | grep -q ",type/docs," || echo "$labels_with_bounds" | grep -q ",area/docs,"; then
          LABEL_TYPE="docs"
        fi
        
        # Always run AI classification for validation (no HTML stripping needed)
        AI_TYPE=""
        
        if [ -n "$OPENAI_API_KEY" ]; then
          echo "Using AI classification..."
          
          # Truncate description to 2000 chars (no HTML stripping)
          truncated_body=$(echo "$PR_BODY" | head -c 2000)
          
          # Build JSON payload using jq to avoid escaping issues
          user_content="Files changed:\n${FILE_PATHS}\n\nTitle: ${PR_TITLE}\n\nDescription: ${truncated_body}"
          
          payload=$(jq -n \
            --arg model "gpt-4o-mini" \
            --arg system_prompt "You are an expert Grafana engineer helping external contributors get their pull requests ready for review. Your task is to accurately classify each PR so it can be routed to the right team and reviewed efficiently.\n\nClassify this PR into ONE category:\n- docs: Changes to documentation, comments, or markdown files\n- bugfix: Fixes broken functionality, errors, or incorrect behavior\n- feature: Adds new functionality or capabilities that didn't exist before\n\nConsider the file paths, title, and description together. Respond with only one word." \
            --arg user_msg "$user_content" \
            '{
              model: $model,
              messages: [
                {role: "system", content: $system_prompt},
                {role: "user", content: $user_msg}
              ],
              temperature: 0.2,
              max_tokens: 5
            }')
          
          # Call OpenAI API
          api_response=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$payload")
          
          # Check for API errors
          api_error=$(echo "$api_response" | jq -r '.error.message // ""')
          if [ -n "$api_error" ]; then
            echo "OpenAI API error: $api_error"
            AI_TYPE=""
          else
            # Parse and validate response (updated regex - no refactor)
            llm_type=$(echo "$api_response" | jq -r '.choices[0].message.content // ""' | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')
            
            if echo "$llm_type" | grep -qE "^(docs|bugfix|feature)$"; then
              AI_TYPE="$llm_type"
              echo "AI classified as: $AI_TYPE"
            else
              echo "AI classification failed (response: $llm_type), no AI suggestion"
              AI_TYPE=""
            fi
          fi
        else
          echo "No API key - AI validation skipped"
          AI_TYPE=""
        fi
        
        # Compare and resolve label vs AI classification
        if [ -n "$LABEL_TYPE" ] && [ -n "$AI_TYPE" ] && [ "$LABEL_TYPE" != "$AI_TYPE" ]; then
          # Disagreement: keep existing label, flag for warning
          echo "WARNING: Classification mismatch - Label: $LABEL_TYPE vs AI: $AI_TYPE"
          echo "disagreement=true" >> "$GITHUB_OUTPUT"
          echo "disagreement-label=$LABEL_TYPE" >> "$GITHUB_OUTPUT"
          echo "disagreement-ai=$AI_TYPE" >> "$GITHUB_OUTPUT"
          TYPE="$LABEL_TYPE"
          
        elif [ -n "$LABEL_TYPE" ]; then
          # Label exists (AI agrees or didn't run)
          echo "Using existing label: $LABEL_TYPE"
          TYPE="$LABEL_TYPE"
          echo "disagreement=false" >> "$GITHUB_OUTPUT"
          
        elif [ -n "$AI_TYPE" ]; then
          # No label exists, use AI classification
          echo "No existing label - using AI: $AI_TYPE"
          TYPE="$AI_TYPE"
          echo "disagreement=false" >> "$GITHUB_OUTPUT"
          
        else
          # Fallback: no label and AI failed/skipped
          echo "No label and AI unavailable - defaulting to feature"
          TYPE="feature"
          echo "disagreement=false" >> "$GITHUB_OUTPUT"
        fi
        
        echo "type=$TYPE" >> "$GITHUB_OUTPUT"
        echo "type-label=pr-category:$TYPE" >> "$GITHUB_OUTPUT"
        
        echo "Categorized as: size=$SIZE, type=$TYPE"

