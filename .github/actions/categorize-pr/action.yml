name: 'Categorize PR'
description: 'Automatically categorize PRs by size and type based on changes and existing labels'
inputs:
  github-token:
    description: 'GitHub token for API access'
    required: true
  pr-number:
    description: 'Pull request number'
    required: true
  pr-body:
    description: 'Pull request body/description'
    required: false
    default: ''
outputs:
  size:
    description: 'Detected size category (small/medium/large)'
    value: ${{ steps.categorize.outputs.size }}
  type:
    description: 'Detected type category (docs/bugfix/refactor/feature)'
    value: ${{ steps.categorize.outputs.type }}
  size-label:
    description: 'Size label to apply'
    value: ${{ steps.categorize.outputs.size-label }}
  type-label:
    description: 'Type label to apply'
    value: ${{ steps.categorize.outputs.type-label }}
  conflict:
    description: 'Whether there is a conflict between contributor selection and auto-detection'
    value: ${{ steps.categorize.outputs.conflict }}

runs:
  using: 'composite'
  steps:
    - name: Get PR details and changes
      id: pr-details
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ inputs.pr-number }}
      run: |
        # Get PR file changes and metadata
        pr_data=$(gh pr view "$PR_NUMBER" --json files,title,body,labels)
        pr_files=$(echo "$pr_data" | jq '.files')
        
        # Count lines changed and files touched
        lines_added=$(echo "$pr_files" | jq '[.[].additions] | add // 0')
        lines_deleted=$(echo "$pr_files" | jq '[.[].deletions] | add // 0')
        total_lines=$((lines_added + lines_deleted))
        files_count=$(echo "$pr_files" | jq 'length')
        
        echo "lines-changed=$total_lines" >> "$GITHUB_OUTPUT"
        echo "files-count=$files_count" >> "$GITHUB_OUTPUT"
        
        # Get file paths for type detection
        file_paths=$(echo "$pr_files" | jq -r '.[].path' | tr '\n' ',' | sed 's/,$//')
        echo "file-paths=$file_paths" >> "$GITHUB_OUTPUT"
        
        # Get existing labels
        labels=$(echo "$pr_data" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
        echo "existing-labels=$labels" >> "$GITHUB_OUTPUT"
        
        # Get PR title (for type detection in addition to body)
        pr_title=$(echo "$pr_data" | jq -r '.title // ""')
        echo "pr-title=$pr_title" >> "$GITHUB_OUTPUT"

    - name: Categorize PR
      id: categorize
      shell: bash
      env:
        LINES_CHANGED: ${{ steps.pr-details.outputs.lines-changed }}
        FILES_COUNT: ${{ steps.pr-details.outputs.files-count }}
        FILE_PATHS: ${{ steps.pr-details.outputs.file-paths }}
        EXISTING_LABELS: ${{ steps.pr-details.outputs.existing-labels }}
        PR_BODY: ${{ inputs.pr-body }}
        PR_TITLE: ${{ steps.pr-details.outputs.pr-title }}
      run: |
        # Determine size
        if [ "$LINES_CHANGED" -lt 100 ] && [ "$FILES_COUNT" -le 3 ]; then
          SIZE="small"
        elif [ "$LINES_CHANGED" -lt 500 ] && [ "$FILES_COUNT" -le 10 ]; then
          SIZE="medium"
        else
          SIZE="large"
        fi
        
        echo "size=$SIZE" >> "$GITHUB_OUTPUT"
        echo "size-label=size:$SIZE" >> "$GITHUB_OUTPUT"
        
        # Determine type from existing labels first
        TYPE=""
        if echo "$EXISTING_LABELS" | grep -q "type/docs\|area/docs"; then
          TYPE="docs"
        elif echo "$EXISTING_LABELS" | grep -q "type/bug"; then
          TYPE="bugfix"
        elif echo "$EXISTING_LABELS" | grep -q "type/feature"; then
          TYPE="feature"
        elif echo "$EXISTING_LABELS" | grep -q "type/refactor"; then
          TYPE="refactor"
        fi
        
        # Fallback to file path analysis if no type labels exist
        if [ -z "$TYPE" ]; then
          # Strip HTML comments and unfilled template placeholders from PR body
          cleaned_body=$(echo "$PR_BODY" | sed 's/<!--.*-->//g')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/\b(Closes|closes|Fixes|fixes|Resolves|resolves) #[[:space:]]*$//g')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/\b(Closes|closes|Fixes|fixes|Resolves|resolves) #[[:space:]]*\n/\n/g')
          
          # Strip common template questions that contain "fix" to avoid false positives
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/Which issue.*does this PR fix\?.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/prove my fix is effective.*//gi')
          cleaned_body=$(echo "$cleaned_body" | sed -E 's/\*\*Special notes for your reviewer:\*\*.*//gi')
          
          # Combine title and cleaned body for keyword analysis
          combined_text="$PR_TITLE $cleaned_body"
          
          # Check for documentation keywords first (before file paths)
          if echo "$combined_text" | grep -qiE "\b(documentation|docs|swagger|openapi|jsdoc|api.?docs)\b"; then
            TYPE="docs"
          elif echo "$FILE_PATHS" | grep -q "docs/\|contribute/\|\.md$"; then
            TYPE="docs"
          elif echo "$FILE_PATHS" | grep -qE "(^|/)tests?/.*\.(test|spec)\.|__tests__/"; then
            # Only test files in test directories (not spec files like Swagger)
            TYPE="bugfix"
          elif echo "$combined_text" | grep -qiE "\b(fix(es|ed)?|bug|closes? #[0-9]+|resolves? #[0-9]+)\b"; then
            # Removed standalone "issue" - too vague
            TYPE="bugfix"
          elif echo "$combined_text" | grep -qiE "\b(refactor(ing)?|reorganiz(e|ing)|restructur(e|ing)|clean(-| )?up|simplify|consolidate|extract)\b"; then
            TYPE="refactor"
          elif echo "$combined_text" | grep -qiE "\b(feat(ure)?|add(s|ed|ing)?|new|implement(s|ed|ing)?|enhance(ment)?|update(s|d|ing)?|upgrade(s|d)?|improve(s|d|ment)?)\b"; then
            TYPE="feature"
          else
            # Default to feature for code changes
            TYPE="feature"
          fi
        fi
        
        echo "type=$TYPE" >> "$GITHUB_OUTPUT"
        echo "type-label=pr-category:$TYPE" >> "$GITHUB_OUTPUT"
        
        # Check for conflicts with contributor selection
        CONFLICT="false"
        if echo "$PR_BODY" | grep -q "üü¢ Small" && [ "$SIZE" != "small" ]; then
          CONFLICT="true"
        elif echo "$PR_BODY" | grep -q "üü° Medium" && [ "$SIZE" != "medium" ]; then
          CONFLICT="true"
        elif echo "$PR_BODY" | grep -q "üî¥ Large" && [ "$SIZE" != "large" ]; then
          CONFLICT="true"
        fi
        
        echo "conflict=$CONFLICT" >> "$GITHUB_OUTPUT"
        
        echo "‚úÖ Categorized as: size=$SIZE, type=$TYPE"
        if [ "$CONFLICT" = "true" ]; then
          echo "‚ö†Ô∏è  Conflict detected with contributor's self-selection"
        fi

