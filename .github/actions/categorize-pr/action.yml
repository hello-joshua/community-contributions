name: 'Categorize PR'
description: 'Automatically categorize PRs by size and type based on changes and existing labels'
inputs:
  github-token:
    description: 'GitHub token for API access'
    required: true
  pr-number:
    description: 'Pull request number'
    required: true
  pr-body:
    description: 'Pull request body/description'
    required: false
    default: ''
  openai-api-key:
    description: 'OpenAI API key for LLM-based type classification'
    required: false
    default: ''
outputs:
  size:
    description: 'Detected size category (small/medium/large)'
    value: ${{ steps.categorize.outputs.size }}
  type:
    description: 'Detected type category (docs/bugfix/refactor/feature)'
    value: ${{ steps.categorize.outputs.type }}
  size-label:
    description: 'Size label to apply'
    value: ${{ steps.categorize.outputs.size-label }}
  type-label:
    description: 'Type label to apply'
    value: ${{ steps.categorize.outputs.type-label }}
  conflict:
    description: 'Whether there is a conflict between contributor selection and auto-detection'
    value: ${{ steps.categorize.outputs.conflict }}

runs:
  using: 'composite'
  steps:
    - name: Get PR details and changes
      id: pr-details
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ inputs.pr-number }}
      run: |
        # Get PR file changes and metadata
        pr_data=$(gh pr view "$PR_NUMBER" --json files,title,body,labels)
        pr_files=$(echo "$pr_data" | jq '.files')
        
        # Count lines changed and files touched
        lines_added=$(echo "$pr_files" | jq '[.[].additions] | add // 0')
        lines_deleted=$(echo "$pr_files" | jq '[.[].deletions] | add // 0')
        total_lines=$((lines_added + lines_deleted))
        files_count=$(echo "$pr_files" | jq 'length')
        
        echo "lines-changed=$total_lines" >> "$GITHUB_OUTPUT"
        echo "files-count=$files_count" >> "$GITHUB_OUTPUT"
        
        # Get file paths for type detection
        file_paths=$(echo "$pr_files" | jq -r '.[].path' | tr '\n' ',' | sed 's/,$//')
        echo "file-paths=$file_paths" >> "$GITHUB_OUTPUT"
        
        # Get existing labels
        labels=$(echo "$pr_data" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
        echo "existing-labels=$labels" >> "$GITHUB_OUTPUT"
        
        # Get PR title (for type detection in addition to body)
        pr_title=$(echo "$pr_data" | jq -r '.title // ""')
        echo "pr-title=$pr_title" >> "$GITHUB_OUTPUT"

    - name: Categorize PR
      id: categorize
      shell: bash
      env:
        LINES_CHANGED: ${{ steps.pr-details.outputs.lines-changed }}
        FILES_COUNT: ${{ steps.pr-details.outputs.files-count }}
        FILE_PATHS: ${{ steps.pr-details.outputs.file-paths }}
        EXISTING_LABELS: ${{ steps.pr-details.outputs.existing-labels }}
        PR_BODY: ${{ inputs.pr-body }}
        PR_TITLE: ${{ steps.pr-details.outputs.pr-title }}
        OPENAI_API_KEY: ${{ inputs.openai-api-key }}
      run: |
        # Determine size
        if [ "$LINES_CHANGED" -lt 100 ] && [ "$FILES_COUNT" -le 3 ]; then
          SIZE="small"
        elif [ "$LINES_CHANGED" -lt 500 ] && [ "$FILES_COUNT" -le 10 ]; then
          SIZE="medium"
        else
          SIZE="large"
        fi
        
        echo "size=$SIZE" >> "$GITHUB_OUTPUT"
        echo "size-label=size:$SIZE" >> "$GITHUB_OUTPUT"
        
        # Determine type from existing labels first
        TYPE=""
        if echo "$EXISTING_LABELS" | grep -q "type/docs\|area/docs"; then
          TYPE="docs"
        elif echo "$EXISTING_LABELS" | grep -q "type/bug"; then
          TYPE="bugfix"
        elif echo "$EXISTING_LABELS" | grep -q "type/feature"; then
          TYPE="feature"
        elif echo "$EXISTING_LABELS" | grep -q "type/refactor"; then
          TYPE="refactor"
        fi
        
        # Fallback to AI-powered classification if no type labels exist
        if [ -z "$TYPE" ]; then
          # Sanitize PR body: strip HTML comments and truncate
          cleaned_body=$(echo "$PR_BODY" | sed 's/<!--.*-->//g' | head -c 1500)
          
          # Try LLM classification first if API key is available
          if [ -n "$OPENAI_API_KEY" ]; then
            echo "Using AI classification..."
            
            # Prepare file context for better classification
            file_context=""
            if echo "$FILE_PATHS" | grep -q "docs/\|contribute/\|\.md$"; then
              file_context="Modified files: docs/markdown. "
            elif echo "$FILE_PATHS" | grep -qE "test|spec"; then
              file_context="Modified files: tests. "
            fi
            
            # Build JSON payload using jq to avoid escaping issues
            user_content="${file_context}Title: ${PR_TITLE}\n\nDescription: ${cleaned_body}"
            
            payload=$(jq -n \
              --arg model "gpt-4o-mini" \
              --arg system_prompt "Classify this PR into ONE category: docs, bugfix, feature, or refactor.\n\nRules:\n- docs: Documentation, README, comments, markdown\n- bugfix: Fixes bugs, errors, crashes, regressions\n- refactor: Code restructuring without new behavior\n- feature: New functionality, enhancements, improvements\n\nRespond with ONLY the category word, nothing else." \
              --arg user_msg "$user_content" \
              '{
                model: $model,
                messages: [
                  {role: "system", content: $system_prompt},
                  {role: "user", content: $user_msg}
                ],
                temperature: 0.2,
                max_tokens: 5
              }')
            
            # Call OpenAI API
            api_response=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "$payload")
            
            # Debug: show API response (for troubleshooting)
            echo "API response: $api_response"
            
            # Check for API errors
            api_error=$(echo "$api_response" | jq -r '.error.message // ""')
            if [ -n "$api_error" ]; then
              echo "OpenAI API error: $api_error"
              TYPE="feature"
            else
              # Parse and validate response
              llm_type=$(echo "$api_response" | jq -r '.choices[0].message.content // ""' | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')
              
              if echo "$llm_type" | grep -qE "^(docs|bugfix|feature|refactor)$"; then
                TYPE="$llm_type"
                echo "AI classified as: $TYPE"
              else
                echo "AI classification failed (response: $llm_type), defaulting to feature"
                TYPE="feature"
              fi
            fi
          else
            echo "No API key - defaulting to feature"
            TYPE="feature"
          fi
        fi
        
        # Ensure TYPE is set (should never be empty, but safety check)
        if [ -z "$TYPE" ]; then
          echo "ERROR: TYPE is empty after scoring! Defaulting to feature"
          TYPE="feature"
        fi
        
        echo "type=$TYPE" >> "$GITHUB_OUTPUT"
        echo "type-label=pr-category:$TYPE" >> "$GITHUB_OUTPUT"
        
        # Check for conflicts with contributor selection
        CONFLICT="false"
        if echo "$PR_BODY" | grep -q "Small" && [ "$SIZE" != "small" ]; then
          CONFLICT="true"
        elif echo "$PR_BODY" | grep -q "Medium" && [ "$SIZE" != "medium" ]; then
          CONFLICT="true"
        elif echo "$PR_BODY" | grep -q "Large" && [ "$SIZE" != "large" ]; then
          CONFLICT="true"
        fi
        
        echo "conflict=$CONFLICT" >> "$GITHUB_OUTPUT"
        
        echo "Categorized as: size=$SIZE, type=$TYPE"
        if [ "$CONFLICT" = "true" ]; then
          echo "WARNING: Conflict detected with contributor's self-selection"
        fi

